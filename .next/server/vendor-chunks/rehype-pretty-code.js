"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code";
exports.ids = ["vendor-chunks/rehype-pretty-code"];
exports.modules = {

/***/ "(rsc)/./node_modules/rehype-pretty-code/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rehype-pretty-code/dist/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   rehypePrettyCode: () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiki */ \"shiki\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/./node_modules/hast-util-to-string/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/./node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unified */ \"(rsc)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/./node_modules/rehype-parse/lib/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([shiki__WEBPACK_IMPORTED_MODULE_0__]);\nshiki__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n// src/index.ts\nfunction isJSONTheme(value) {\n  return value ? Object.hasOwn(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n  return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n  return value ? value.type === \"text\" : false;\n}\nfunction isInlineCode(element, parent) {\n  return element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\";\n}\nfunction isBlockCode(element) {\n  return element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\";\n}\nfunction getInlineCodeLang(meta, defaultFallbackLang) {\n  const placeholder = \"\\0\";\n  let temp = meta.replace(/\\\\\\\\/g, placeholder);\n  temp = temp.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\");\n  const lang = temp.match(/{:([a-zA-Z.-]+)}$/)?.[1];\n  return lang?.replace(new RegExp(placeholder, \"g\"), \"\\\\\") || defaultFallbackLang;\n}\nfunction parseBlockMetaString(element, filter, defaultFallback) {\n  let meta = filter(\n    // @ts-expect-error: TODO handle this\n    element.data?.meta ?? element.properties?.metastring ?? \"\"\n  );\n  const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n  const title = titleMatch?.[1] ?? null;\n  meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n  const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n  const caption = captionMatch?.[1] ?? null;\n  meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n  let lang = defaultFallback;\n  if (element.properties && Array.isArray(element.properties.className) && typeof element.properties.className[0] === \"string\" && element.properties.className[0].startsWith(\"language-\")) {\n    lang = element.properties.className[0].replace(\"language-\", \"\");\n  }\n  return {\n    title,\n    caption,\n    lang,\n    meta\n  };\n}\nfunction getThemeNames(theme) {\n  if (isJSONTheme(theme)) {\n    return [theme.name];\n  }\n  if (typeof theme === \"string\") {\n    return [theme];\n  }\n  return Object.values(theme).map(\n    (theme2) => typeof theme2 === \"string\" ? theme2 : theme2.name\n  );\n}\nfunction replaceLineClass(element) {\n  if (Array.isArray(element.properties?.className) && element.properties.className.includes(\"line\")) {\n    const className = element.properties.className.filter((c) => c !== \"line\");\n    element.properties.className = className.length > 0 ? className : void 0;\n    element.properties[\"data-line\"] = \"\";\n  }\n}\nfunction getLineId(lineNumber, meta) {\n  const segments = meta.match(/\\{[^}]+\\}#[a-zA-Z0-9]+/g);\n  if (!segments)\n    return null;\n  for (const segment of segments) {\n    const [range, id] = segment.split(\"#\");\n    if (!(range && id))\n      continue;\n    const match = range.match(/\\{(.*?)\\}/);\n    const capture = match?.[1];\n    if (capture && parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(capture).includes(lineNumber)) {\n      return id;\n    }\n  }\n  return null;\n}\n\n// src/chars/splitElement.ts\nfunction splitElement({\n  elements,\n  elementToWrap,\n  innerString,\n  rightString,\n  leftString,\n  rest,\n  nextElementContinues,\n  index,\n  ignoreChars\n}) {\n  if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n    return [elementToWrap, index];\n  }\n  let newIndex = index;\n  const textElement = elementToWrap.children[0];\n  if (isText(textElement)) {\n    textElement.value = innerString;\n  }\n  let rightStr = rightString;\n  const leftStr = leftString;\n  if (rest.length > 0) {\n    rightStr += rest.map((s) => s === \"\" ? innerString : innerString + s).join(\"\");\n  }\n  if (leftStr.length > 0) {\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: leftStr }]\n    });\n  }\n  if (rightStr.length > 0 && !nextElementContinues) {\n    newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: rightStr }]\n    });\n  }\n  return [elementToWrap, index + 1];\n}\nfunction nextElementMaybeContinuesChars({\n  elements,\n  nextIndex,\n  remainingPart\n}) {\n  if (remainingPart === \"\") {\n    return false;\n  }\n  const nextNode = elements[nextIndex];\n  const content = getContent(nextNode);\n  if (!content) {\n    return false;\n  }\n  const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n  const overlap = findOverlap(content, remainingPart);\n  if (overlap === remainingPart && content.startsWith(remainingPart)) {\n    return true;\n  }\n  if (includesNext) {\n    return nextElementMaybeContinuesChars({\n      elements,\n      nextIndex: nextIndex + 1,\n      remainingPart: remainingPart.replace(content, \"\")\n    });\n  }\n  return false;\n}\nfunction getContent(node) {\n  if (!node)\n    return;\n  return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(node);\n}\nfunction findOverlap(a, b) {\n  if (b.length === 0) {\n    return \"\";\n  }\n  if (a.endsWith(b)) {\n    return b;\n  }\n  if (a.indexOf(b) >= 0) {\n    return b;\n  }\n  return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n  return s.split(\"\").reverse().join(\"\");\n}\n\n// src/chars/getElementsToHighlight.ts\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n  const toWrap = [];\n  let charsSoFar = \"\";\n  if (element.children) {\n    const elements = element.children;\n    for (let i = startIndex; i < elements.length; i++) {\n      const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n      if (remaining === \"\") {\n        return toWrap;\n      }\n      const maybeElement = elements[i];\n      if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n      Object.hasOwn(\n        maybeElement.properties ?? {},\n        \"rehype-pretty-code-visited\"\n      )) {\n        continue;\n      }\n      const content = getContent(maybeElement) || \"\";\n      if (content === chars || charsSoFar + content === chars) {\n        toWrap.push({ element: maybeElement, index: i });\n        return toWrap;\n      }\n      if (chars.startsWith(charsSoFar + content)) {\n        if (nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: remaining.replace(content, \"\")\n        })) {\n          toWrap.push({ element: elements[i], index: i });\n          charsSoFar += content;\n          continue;\n        }\n      }\n      const overlap = findOverlap(content, remaining);\n      const partialMatch = overlap && remaining.startsWith(overlap);\n      if (partialMatch) {\n        const nextPart = remaining.replace(overlap, \"\");\n        if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: nextPart\n        })) {\n          continue;\n        }\n        const splitParts = content.split(overlap);\n        const [leftPart, rightPart, ...rest] = splitParts;\n        if (rightPart || leftPart || rest.length > 0) {\n          const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n          const nextNodeOverlap = findOverlap(withNextNode, remaining);\n          const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n          if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n            const rightString = rightPart.replace(overlap, \"\");\n            const innerString = overlap;\n            const leftString = content.substring(0, splitIndex);\n            const nextElementContinues = nextElementMaybeContinuesChars({\n              elements,\n              nextIndex: i + 1,\n              remainingPart: nextPart\n            });\n            const [newElement, updatedIndex] = splitElement({\n              elements,\n              elementToWrap: elements[i],\n              innerString,\n              rightString,\n              leftString,\n              rest,\n              nextElementContinues,\n              index: i,\n              ignoreChars\n            });\n            charsSoFar += overlap;\n            toWrap.push({\n              element: newElement,\n              index: updatedIndex\n            });\n          }\n        }\n      }\n    }\n  }\n  return toWrap;\n}\n\n// src/chars/wrapHighlightedChars.ts\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n  if (!elementsToWrap || elementsToWrap.length === 0) {\n    return;\n  }\n  const [{ element }] = elementsToWrap;\n  if (ignoreWord) {\n    if (element.properties) {\n      element.properties[\"rehype-pretty-code-visited\"] = \"\";\n    }\n    return;\n  }\n  if (elementsToWrap.length > 1) {\n    parentElement.children.splice(\n      elementsToWrap[0].index,\n      elementsToWrap.length,\n      {\n        type: \"element\",\n        tagName: \"mark\",\n        properties: { \"data-highlighted-chars-mark\": \"\" },\n        children: elementsToWrap.map(({ element: element3 }) => element3)\n      }\n    );\n    const element2 = parentElement.children[elementsToWrap[0].index];\n    if (!isElement(element2)) {\n      return;\n    }\n    const wordStr = element2.children.reduce((acc, node) => {\n      const textElement = isElement(node) ? node.children[0] : null;\n      if (isText(textElement)) {\n        return acc + textElement.value;\n      }\n      return acc;\n    }, \"\");\n    const id = options.idsMap.get(wordStr);\n    element2.properties = element2.properties || {};\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    onVisitHighlightedChars?.(element2, id);\n  } else {\n    const [{ element: element2 }] = elementsToWrap;\n    const textElement = element2.children[0];\n    if (!isText(textElement)) {\n      return;\n    }\n    const id = options.idsMap.get(textElement.value);\n    element2.properties = element2.properties || {};\n    element2.properties[\"rehype-pretty-code-visited\"] = \"\";\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    element2.children = [\n      {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          style: element2.properties.style\n        },\n        children: element2.children\n      }\n    ];\n    element2.properties.style = void 0;\n    onVisitHighlightedChars?.(element2, id);\n  }\n}\nfunction charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n  const { ranges = [] } = options;\n  const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n  charsList.forEach((chars, index) => {\n    if (chars && textContent?.includes(chars)) {\n      let textContent2 = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n      let startIndex = 0;\n      while (textContent2.includes(chars)) {\n        const currentCharsRange = ranges[index] || [];\n        const id = `${chars}-${index}`;\n        options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n        const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n        const elementsToWrap = getElementsToHighlight(\n          element,\n          chars,\n          startIndex,\n          ignoreChars\n        );\n        if (elementsToWrap.length === 0)\n          break;\n        wrapHighlightedChars(\n          element,\n          elementsToWrap,\n          options,\n          ignoreChars,\n          onVisitHighlightedChars\n        );\n        startIndex = Math.max(\n          elementsToWrap[elementsToWrap.length - 1].index - 2,\n          0\n        );\n        textContent2 = element.children.map((childNode) => {\n          const props = isElement(childNode) ? childNode.properties : {};\n          if (props && !Object.hasOwn(props, \"rehype-pretty-code-visited\") && !Object.hasOwn(props, \"data-highlighted-chars-mark\")) {\n            return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(childNode);\n          }\n        }).join(\"\");\n      }\n    }\n  });\n  element.children.forEach((childNode) => {\n    if (!isElement(childNode))\n      return;\n    if (Object.hasOwn(childNode.properties, \"rehype-pretty-code-visited\")) {\n      childNode.properties[\"rehype-pretty-code-visited\"] = void 0;\n    }\n  });\n}\n\n// src/index.ts\nfunction apply(element, {\n  tree,\n  lang,\n  title,\n  caption,\n  inline = false,\n  keepBackground = true,\n  grid = true,\n  lineNumbersMaxDigits = 1,\n  theme,\n  onVisitTitle,\n  onVisitCaption\n}) {\n  element.tagName = inline ? \"span\" : \"figure\";\n  element.properties[\"data-rehype-pretty-code-figure\"] = \"\";\n  const codeData = element.children[0]?.data;\n  element.children = [tree].map((tree2) => {\n    const pre = tree2.children[0];\n    const themeNames = getThemeNames(theme);\n    const themeNamesString = themeNames.join(\" \");\n    if (!(isElement(pre) && pre.properties)) {\n      return [];\n    }\n    const code = pre.children[0];\n    if (Array.isArray(pre.properties.className) && pre.properties.className.includes(\"shiki\")) {\n      const className = pre.properties.className.filter(\n        (c) => c !== \"shiki\" && c !== \"shiki-themes\" && (typeof c === \"string\" ? !themeNames.includes(c) : true)\n      );\n      pre.properties.className = className.length > 0 ? className : void 0;\n    }\n    if (!keepBackground) {\n      pre.properties.style = void 0;\n    }\n    pre.properties[\"data-language\"] = lang;\n    pre.properties[\"data-theme\"] = themeNamesString;\n    if (!(isElement(code) && code.properties)) {\n      return [];\n    }\n    code.properties[\"data-language\"] = lang;\n    code.properties[\"data-theme\"] = themeNamesString;\n    code.data = codeData;\n    if (inline) {\n      if (keepBackground) {\n        code.properties.style = pre.properties.style;\n      }\n      return code;\n    }\n    if (grid) {\n      if (code.properties.style) {\n        code.properties.style += \"display: grid;\";\n      } else {\n        code.properties.style = \"display: grid;\";\n      }\n    }\n    if (Object.hasOwn(code.properties, \"data-line-numbers\")) {\n      code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n    }\n    const fragments = [];\n    if (title) {\n      const elementContent = {\n        type: \"element\",\n        tagName: caption ? \"div\" : \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-title\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: title }]\n      };\n      onVisitTitle?.(elementContent);\n      fragments.push(elementContent);\n    }\n    fragments.push(pre);\n    if (caption) {\n      const elementContent = {\n        type: \"element\",\n        tagName: \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-caption\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: caption }]\n      };\n      onVisitCaption?.(elementContent);\n      fragments.push(elementContent);\n    }\n    return fragments;\n  }).flatMap((c) => c);\n}\nvar globalHighlighterCache = /* @__PURE__ */ new Map();\nvar hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_3__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { fragment: true });\nvar src_default = rehypePrettyCode;\nfunction rehypePrettyCode(options = {}) {\n  const {\n    grid = true,\n    theme = \"github-dark-dimmed\",\n    keepBackground = true,\n    defaultLang = \"\",\n    tokensMap = {},\n    filterMetaString = (v) => v,\n    getHighlighter: getHighlighter$1 = shiki__WEBPACK_IMPORTED_MODULE_0__.getHighlighter,\n    transformers,\n    onVisitLine,\n    onVisitHighlightedLine,\n    onVisitHighlightedChars,\n    onVisitTitle,\n    onVisitCaption\n  } = options;\n  const key = JSON.stringify(theme);\n  let cachedHighlighter = globalHighlighterCache.get(key);\n  if (!cachedHighlighter) {\n    cachedHighlighter = getHighlighter$1({\n      themes: isJSONTheme(theme) || typeof theme === \"string\" ? [theme] : Object.values(theme),\n      langs: [\"plaintext\"]\n    });\n    globalHighlighterCache.set(key, cachedHighlighter);\n  }\n  const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n  const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n  function getOptions(lang, meta) {\n    const multipleThemes = !isJSONTheme(theme) && typeof theme === \"object\" ? theme : null;\n    const singleTheme = isJSONTheme(theme) || typeof theme === \"string\" ? theme : null;\n    return {\n      lang,\n      meta: { __raw: meta },\n      transformers,\n      defaultColor: typeof theme === \"string\" ? theme : false,\n      ...multipleThemes ? { themes: multipleThemes } : { theme: singleTheme }\n    };\n  }\n  return async (tree) => {\n    const langsToLoad = /* @__PURE__ */ new Set();\n    const highlighter = await cachedHighlighter;\n    if (!highlighter)\n      return;\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent)) {\n        const textElement = element.children[0];\n        if (!isText(textElement))\n          return;\n        const value = textElement.value;\n        if (!value)\n          return;\n        const lang = getInlineCodeLang(value, defaultInlineCodeLang);\n        if (lang && lang[0] !== \".\") {\n          langsToLoad.add(lang);\n        }\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement))\n          return;\n        const { lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (lang) {\n          langsToLoad.add(lang);\n        }\n      }\n    });\n    try {\n      await Promise.allSettled(\n        Array.from(langsToLoad).map((lang) => {\n          try {\n            return highlighter.loadLanguage(\n              lang\n            );\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        })\n      );\n    } catch (e) {\n      console.error(e);\n    }\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent)) {\n        const textElement = element.children[0];\n        if (!isText(textElement))\n          return;\n        const value = textElement.value;\n        if (!value)\n          return;\n        const keepLangPart = /\\\\{:[a-zA-Z.-]+}$/.test(value);\n        const strippedValue = keepLangPart ? value.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\") : value.replace(/{:[a-zA-Z.-]+}$/, \"\");\n        textElement.value = strippedValue;\n        const lang = keepLangPart ? \"\" : getInlineCodeLang(value, defaultInlineCodeLang);\n        const isLang = lang[0] !== \".\";\n        if (!lang)\n          return;\n        let codeTree;\n        if (isLang) {\n          try {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(lang))\n            );\n          } catch {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\"))\n            );\n          }\n        } else {\n          const themeNames = getThemeNames(theme);\n          const isMultiTheme = typeof theme === \"object\" && !isJSONTheme(theme);\n          const themeKeys = isMultiTheme ? Object.keys(theme) : null;\n          const colorsByTheme = themeNames.map(\n            (name) => name ? highlighter.getTheme(name).settings.find(\n              ({ scope }) => scope?.includes(tokensMap[lang.slice(1)] ?? lang.slice(1))\n            )?.settings.foreground ?? \"inherit\" : \"inherit\"\n          );\n          if (isMultiTheme && themeKeys) {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"${themeKeys.map((key2, i) => `--shiki-${key2}:${colorsByTheme[i]}`).join(\";\")}\">${strippedValue}</span></code></pre>`\n            );\n          } else {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"color:${colorsByTheme[0]}\">${strippedValue}</span></code></pre>`\n            );\n          }\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", replaceLineClass);\n        apply(element, {\n          tree: codeTree,\n          lang: isLang ? lang : \".token\",\n          inline: true,\n          keepBackground,\n          theme\n        });\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement))\n          return;\n        const textElement = codeElement.children[0];\n        const { title, caption, meta, lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (!lang || lang === \"math\")\n          return;\n        const lineNumbers = [];\n        if (meta) {\n          const matches = meta.matchAll(/\\B\\{(.*?)\\}\\B/g);\n          for (const match of matches) {\n            if (match[1]) {\n              lineNumbers.push(...parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(match[1]));\n            }\n          }\n        }\n        let lineNumbersMaxDigits = 0;\n        const lineIdMap = /* @__PURE__ */ new Map();\n        const charsList = [];\n        const charsListNumbers = [];\n        const charsListIdMap = /* @__PURE__ */ new Map();\n        const charsMatches = meta ? [\n          ...meta.matchAll(\n            /(?<delimiter>[\"/])(?<chars>.*?)\\k<delimiter>(?<charsIdAndOrRange>\\S*)/g\n          )\n        ] : void 0;\n        lineNumbers.forEach((lineNumber) => {\n          const id = getLineId(lineNumber, meta);\n          id && lineIdMap.set(lineNumber, id);\n        });\n        if (Array.isArray(charsMatches)) {\n          charsMatches.forEach((name) => {\n            const { chars, charsIdAndOrRange } = name.groups;\n            charsList.push(chars);\n            if (charsIdAndOrRange === \"\") {\n              charsListNumbers.push([]);\n            } else {\n              const [range, id] = charsIdAndOrRange.split(\"#\");\n              range && charsListNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(range));\n              id && charsListIdMap.set(chars, id);\n            }\n          });\n        }\n        if (!isText(textElement))\n          return;\n        const strippedValue = textElement.value.replace(/\\n$/, \"\");\n        let codeTree;\n        try {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(strippedValue, getOptions(lang, meta))\n          );\n        } catch {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(\n              strippedValue,\n              getOptions(\"plaintext\", meta)\n            )\n          );\n        }\n        let lineCounter = 0;\n        const charsHighlighterOptions = {\n          ranges: charsListNumbers,\n          idsMap: charsListIdMap,\n          counterMap: /* @__PURE__ */ new Map()\n        };\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", (element2) => {\n          if (element2.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n            if (element2.properties) {\n              element2.properties[\"data-line-numbers\"] = \"\";\n            }\n            const lineNumbersStartAtMatch = reverseString(meta).match(\n              /(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/\n            );\n            const startNumberString = lineNumbersStartAtMatch?.[1];\n            if (startNumberString) {\n              const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n              lineNumbersMaxDigits = startAt;\n              if (element2.properties) {\n                element2.properties.style = `counter-set: line ${startAt};`;\n              }\n            }\n          }\n          if (Array.isArray(element2.properties?.className) && element2.properties?.className?.[0] === \"line\") {\n            if (grid && (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element2) === \"\") {\n              element2.children = [{ type: \"text\", value: \" \" }];\n            }\n            replaceLineClass(element2);\n            onVisitLine?.(element2);\n            lineCounter++;\n            if (lineNumbers.includes(lineCounter)) {\n              element2.properties[\"data-highlighted-line\"] = \"\";\n              const lineId = lineIdMap.get(lineCounter);\n              if (lineId) {\n                element2.properties[\"data-highlighted-line-id\"] = lineId;\n              }\n              onVisitHighlightedLine?.(element2, lineId);\n            }\n            charsHighlighter(\n              element2,\n              charsList,\n              charsHighlighterOptions,\n              onVisitHighlightedChars\n            );\n            lineNumbersMaxDigits++;\n          }\n        });\n        apply(element, {\n          tree: codeTree,\n          lang,\n          title,\n          caption,\n          keepBackground,\n          grid,\n          lineNumbersMaxDigits,\n          theme,\n          onVisitTitle,\n          onVisitCaption\n        });\n      }\n    });\n  };\n}\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDRTtBQUNNO0FBQ0E7QUFDYjtBQUNLOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUcsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBLG1CQUFtQixnREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiw4QkFBOEI7QUFDakQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiwrQkFBK0I7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0Esd0JBQXdCLDZEQUFRO0FBQ2hDLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXdlc29tZS1wd2gtYmxvZy8uL25vZGVfbW9kdWxlcy9yZWh5cGUtcHJldHR5LWNvZGUvZGlzdC9pbmRleC5qcz8yYWQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEhpZ2hsaWdodGVyIH0gZnJvbSAnc2hpa2knO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0JztcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnaGFzdC11dGlsLXRvLXN0cmluZyc7XG5pbXBvcnQgcmFuZ2VQYXJzZXIyIGZyb20gJ3BhcnNlLW51bWVyaWMtcmFuZ2UnO1xuaW1wb3J0IHsgdW5pZmllZCB9IGZyb20gJ3VuaWZpZWQnO1xuaW1wb3J0IHJlaHlwZVBhcnNlIGZyb20gJ3JlaHlwZS1wYXJzZSc7XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gaXNKU09OVGhlbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ0b2tlbkNvbG9yc1wiKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLnR5cGUgPT09IFwiZWxlbWVudFwiIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1RleHQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUudHlwZSA9PT0gXCJ0ZXh0XCIgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSW5saW5lQ29kZShlbGVtZW50LCBwYXJlbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJjb2RlXCIgJiYgaXNFbGVtZW50KHBhcmVudCkgJiYgcGFyZW50LnRhZ05hbWUgIT09IFwicHJlXCIgfHwgZWxlbWVudC50YWdOYW1lID09PSBcImlubGluZUNvZGVcIjtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tDb2RlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJwcmVcIiAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQuY2hpbGRyZW4pICYmIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGlzRWxlbWVudChlbGVtZW50LmNoaWxkcmVuWzBdKSAmJiBlbGVtZW50LmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09IFwiY29kZVwiO1xufVxuZnVuY3Rpb24gZ2V0SW5saW5lQ29kZUxhbmcobWV0YSwgZGVmYXVsdEZhbGxiYWNrTGFuZykge1xuICBjb25zdCBwbGFjZWhvbGRlciA9IFwiXFwwXCI7XG4gIGxldCB0ZW1wID0gbWV0YS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBwbGFjZWhvbGRlcik7XG4gIHRlbXAgPSB0ZW1wLnJlcGxhY2UoL1xcXFwoezpbYS16QS1aLi1dK30pJC8sIFwiJDFcIik7XG4gIGNvbnN0IGxhbmcgPSB0ZW1wLm1hdGNoKC97OihbYS16QS1aLi1dKyl9JC8pPy5bMV07XG4gIHJldHVybiBsYW5nPy5yZXBsYWNlKG5ldyBSZWdFeHAocGxhY2Vob2xkZXIsIFwiZ1wiKSwgXCJcXFxcXCIpIHx8IGRlZmF1bHRGYWxsYmFja0xhbmc7XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrTWV0YVN0cmluZyhlbGVtZW50LCBmaWx0ZXIsIGRlZmF1bHRGYWxsYmFjaykge1xuICBsZXQgbWV0YSA9IGZpbHRlcihcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUT0RPIGhhbmRsZSB0aGlzXG4gICAgZWxlbWVudC5kYXRhPy5tZXRhID8/IGVsZW1lbnQucHJvcGVydGllcz8ubWV0YXN0cmluZyA/PyBcIlwiXG4gICk7XG4gIGNvbnN0IHRpdGxlTWF0Y2ggPSBtZXRhLm1hdGNoKC90aXRsZT1cIihbXlwiXSopXCIvKTtcbiAgY29uc3QgdGl0bGUgPSB0aXRsZU1hdGNoPy5bMV0gPz8gbnVsbDtcbiAgbWV0YSA9IG1ldGEucmVwbGFjZSh0aXRsZU1hdGNoPy5bMF0gPz8gXCJcIiwgXCJcIik7XG4gIGNvbnN0IGNhcHRpb25NYXRjaCA9IG1ldGEubWF0Y2goL2NhcHRpb249XCIoW15cIl0qKVwiLyk7XG4gIGNvbnN0IGNhcHRpb24gPSBjYXB0aW9uTWF0Y2g/LlsxXSA/PyBudWxsO1xuICBtZXRhID0gbWV0YS5yZXBsYWNlKGNhcHRpb25NYXRjaD8uWzBdID8/IFwiXCIsIFwiXCIpO1xuICBsZXQgbGFuZyA9IGRlZmF1bHRGYWxsYmFjaztcbiAgaWYgKGVsZW1lbnQucHJvcGVydGllcyAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUpICYmIHR5cGVvZiBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdID09PSBcInN0cmluZ1wiICYmIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0uc3RhcnRzV2l0aChcImxhbmd1YWdlLVwiKSkge1xuICAgIGxhbmcgPSBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdLnJlcGxhY2UoXCJsYW5ndWFnZS1cIiwgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0aXRsZSxcbiAgICBjYXB0aW9uLFxuICAgIGxhbmcsXG4gICAgbWV0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGhlbWVOYW1lcyh0aGVtZSkge1xuICBpZiAoaXNKU09OVGhlbWUodGhlbWUpKSB7XG4gICAgcmV0dXJuIFt0aGVtZS5uYW1lXTtcbiAgfVxuICBpZiAodHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFt0aGVtZV07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhlbWUpLm1hcChcbiAgICAodGhlbWUyKSA9PiB0eXBlb2YgdGhlbWUyID09PSBcInN0cmluZ1wiID8gdGhlbWUyIDogdGhlbWUyLm5hbWVcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VMaW5lQ2xhc3MoZWxlbWVudCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50LnByb3BlcnRpZXM/LmNsYXNzTmFtZSkgJiYgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5pbmNsdWRlcyhcImxpbmVcIikpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lLmZpbHRlcigoYykgPT4gYyAhPT0gXCJsaW5lXCIpO1xuICAgIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUgPSBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IHZvaWQgMDtcbiAgICBlbGVtZW50LnByb3BlcnRpZXNbXCJkYXRhLWxpbmVcIl0gPSBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMaW5lSWQobGluZU51bWJlciwgbWV0YSkge1xuICBjb25zdCBzZWdtZW50cyA9IG1ldGEubWF0Y2goL1xce1tefV0rXFx9I1thLXpBLVowLTldKy9nKTtcbiAgaWYgKCFzZWdtZW50cylcbiAgICByZXR1cm4gbnVsbDtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3QgW3JhbmdlLCBpZF0gPSBzZWdtZW50LnNwbGl0KFwiI1wiKTtcbiAgICBpZiAoIShyYW5nZSAmJiBpZCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBtYXRjaCA9IHJhbmdlLm1hdGNoKC9cXHsoLio/KVxcfS8pO1xuICAgIGNvbnN0IGNhcHR1cmUgPSBtYXRjaD8uWzFdO1xuICAgIGlmIChjYXB0dXJlICYmIHJhbmdlUGFyc2VyMihjYXB0dXJlKS5pbmNsdWRlcyhsaW5lTnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL2NoYXJzL3NwbGl0RWxlbWVudC50c1xuZnVuY3Rpb24gc3BsaXRFbGVtZW50KHtcbiAgZWxlbWVudHMsXG4gIGVsZW1lbnRUb1dyYXAsXG4gIGlubmVyU3RyaW5nLFxuICByaWdodFN0cmluZyxcbiAgbGVmdFN0cmluZyxcbiAgcmVzdCxcbiAgbmV4dEVsZW1lbnRDb250aW51ZXMsXG4gIGluZGV4LFxuICBpZ25vcmVDaGFyc1xufSkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnRUb1dyYXApICYmIGVsZW1lbnRUb1dyYXAuY2hpbGRyZW4/LlswXT8udHlwZSAhPT0gXCJ0ZXh0XCIgfHwgaWdub3JlQ2hhcnMpIHtcbiAgICByZXR1cm4gW2VsZW1lbnRUb1dyYXAsIGluZGV4XTtcbiAgfVxuICBsZXQgbmV3SW5kZXggPSBpbmRleDtcbiAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50VG9XcmFwLmNoaWxkcmVuWzBdO1xuICBpZiAoaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgIHRleHRFbGVtZW50LnZhbHVlID0gaW5uZXJTdHJpbmc7XG4gIH1cbiAgbGV0IHJpZ2h0U3RyID0gcmlnaHRTdHJpbmc7XG4gIGNvbnN0IGxlZnRTdHIgPSBsZWZ0U3RyaW5nO1xuICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgcmlnaHRTdHIgKz0gcmVzdC5tYXAoKHMpID0+IHMgPT09IFwiXCIgPyBpbm5lclN0cmluZyA6IGlubmVyU3RyaW5nICsgcykuam9pbihcIlwiKTtcbiAgfVxuICBpZiAobGVmdFN0ci5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudHMuc3BsaWNlKG5ld0luZGV4LCAwLCB7XG4gICAgICAuLi5lbGVtZW50VG9XcmFwLFxuICAgICAgcHJvcGVydGllczogeyAuLi5lbGVtZW50VG9XcmFwLnByb3BlcnRpZXMgfSxcbiAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGxlZnRTdHIgfV1cbiAgICB9KTtcbiAgfVxuICBpZiAocmlnaHRTdHIubGVuZ3RoID4gMCAmJiAhbmV4dEVsZW1lbnRDb250aW51ZXMpIHtcbiAgICBuZXdJbmRleCA9IGxlZnRTdHIubGVuZ3RoID4gMCA/IG5ld0luZGV4ICsgMiA6IG5ld0luZGV4ICsgMTtcbiAgICBlbGVtZW50cy5zcGxpY2UobmV3SW5kZXgsIDAsIHtcbiAgICAgIC4uLmVsZW1lbnRUb1dyYXAsXG4gICAgICBwcm9wZXJ0aWVzOiB7IC4uLmVsZW1lbnRUb1dyYXAucHJvcGVydGllcyB9LFxuICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogcmlnaHRTdHIgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2VsZW1lbnRUb1dyYXAsIGluZGV4ICsgMV07XG59XG5mdW5jdGlvbiBuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICBlbGVtZW50cyxcbiAgbmV4dEluZGV4LFxuICByZW1haW5pbmdQYXJ0XG59KSB7XG4gIGlmIChyZW1haW5pbmdQYXJ0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5leHROb2RlID0gZWxlbWVudHNbbmV4dEluZGV4XTtcbiAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQobmV4dE5vZGUpO1xuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaW5jbHVkZXNOZXh0ID0gY29udGVudC5zdGFydHNXaXRoKHJlbWFpbmluZ1BhcnQpIHx8IHJlbWFpbmluZ1BhcnQuc3RhcnRzV2l0aChjb250ZW50KTtcbiAgY29uc3Qgb3ZlcmxhcCA9IGZpbmRPdmVybGFwKGNvbnRlbnQsIHJlbWFpbmluZ1BhcnQpO1xuICBpZiAob3ZlcmxhcCA9PT0gcmVtYWluaW5nUGFydCAmJiBjb250ZW50LnN0YXJ0c1dpdGgocmVtYWluaW5nUGFydCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5jbHVkZXNOZXh0KSB7XG4gICAgcmV0dXJuIG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICBlbGVtZW50cyxcbiAgICAgIG5leHRJbmRleDogbmV4dEluZGV4ICsgMSxcbiAgICAgIHJlbWFpbmluZ1BhcnQ6IHJlbWFpbmluZ1BhcnQucmVwbGFjZShjb250ZW50LCBcIlwiKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENvbnRlbnQobm9kZSkge1xuICBpZiAoIW5vZGUpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gdG9TdHJpbmcobm9kZSk7XG59XG5mdW5jdGlvbiBmaW5kT3ZlcmxhcChhLCBiKSB7XG4gIGlmIChiLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChhLmVuZHNXaXRoKGIpKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgaWYgKGEuaW5kZXhPZihiKSA+PSAwKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgcmV0dXJuIGZpbmRPdmVybGFwKGEsIGIuc3Vic3RyaW5nKDAsIGIubGVuZ3RoIC0gMSkpO1xufVxuZnVuY3Rpb24gcmV2ZXJzZVN0cmluZyhzKSB7XG4gIHJldHVybiBzLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvY2hhcnMvZ2V0RWxlbWVudHNUb0hpZ2hsaWdodC50c1xuZnVuY3Rpb24gZ2V0RWxlbWVudHNUb0hpZ2hsaWdodChlbGVtZW50LCBjaGFycywgc3RhcnRJbmRleCA9IDAsIGlnbm9yZUNoYXJzID0gZmFsc2UpIHtcbiAgY29uc3QgdG9XcmFwID0gW107XG4gIGxldCBjaGFyc1NvRmFyID0gXCJcIjtcbiAgaWYgKGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gY2hhcnNTb0ZhciA/IGNoYXJzLnJlcGxhY2UoY2hhcnNTb0ZhciwgXCJcIikgOiBjaGFycztcbiAgICAgIGlmIChyZW1haW5pbmcgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRvV3JhcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heWJlRWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKCFtYXliZUVsZW1lbnQgfHwgbWF5YmVFbGVtZW50LnR5cGUgIT09IFwiZWxlbWVudFwiIHx8IC8vIGlnbm9yZSBhbnkgcHJldmlvdXNseSBtYXRjaGVkIGNoYXJzIHdpdGhpblxuICAgICAgT2JqZWN0Lmhhc093bihcbiAgICAgICAgbWF5YmVFbGVtZW50LnByb3BlcnRpZXMgPz8ge30sXG4gICAgICAgIFwicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIlxuICAgICAgKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50KG1heWJlRWxlbWVudCkgfHwgXCJcIjtcbiAgICAgIGlmIChjb250ZW50ID09PSBjaGFycyB8fCBjaGFyc1NvRmFyICsgY29udGVudCA9PT0gY2hhcnMpIHtcbiAgICAgICAgdG9XcmFwLnB1c2goeyBlbGVtZW50OiBtYXliZUVsZW1lbnQsIGluZGV4OiBpIH0pO1xuICAgICAgICByZXR1cm4gdG9XcmFwO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJzLnN0YXJ0c1dpdGgoY2hhcnNTb0ZhciArIGNvbnRlbnQpKSB7XG4gICAgICAgIGlmIChuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgcmVtYWluaW5nUGFydDogcmVtYWluaW5nLnJlcGxhY2UoY29udGVudCwgXCJcIilcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0b1dyYXAucHVzaCh7IGVsZW1lbnQ6IGVsZW1lbnRzW2ldLCBpbmRleDogaSB9KTtcbiAgICAgICAgICBjaGFyc1NvRmFyICs9IGNvbnRlbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBmaW5kT3ZlcmxhcChjb250ZW50LCByZW1haW5pbmcpO1xuICAgICAgY29uc3QgcGFydGlhbE1hdGNoID0gb3ZlcmxhcCAmJiByZW1haW5pbmcuc3RhcnRzV2l0aChvdmVybGFwKTtcbiAgICAgIGlmIChwYXJ0aWFsTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbmV4dFBhcnQgPSByZW1haW5pbmcucmVwbGFjZShvdmVybGFwLCBcIlwiKTtcbiAgICAgICAgaWYgKG5leHRQYXJ0ICE9PSBcIlwiICYmIGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSAmJiAhbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgIHJlbWFpbmluZ1BhcnQ6IG5leHRQYXJ0XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BsaXRQYXJ0cyA9IGNvbnRlbnQuc3BsaXQob3ZlcmxhcCk7XG4gICAgICAgIGNvbnN0IFtsZWZ0UGFydCwgcmlnaHRQYXJ0LCAuLi5yZXN0XSA9IHNwbGl0UGFydHM7XG4gICAgICAgIGlmIChyaWdodFBhcnQgfHwgbGVmdFBhcnQgfHwgcmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgd2l0aE5leHROb2RlID0gY29udGVudCArIChnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgPyBnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgOiBcIlwiKTtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZU92ZXJsYXAgPSBmaW5kT3ZlcmxhcCh3aXRoTmV4dE5vZGUsIHJlbWFpbmluZyk7XG4gICAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHdpdGhOZXh0Tm9kZS5pbmRleE9mKG5leHROb2RlT3ZlcmxhcCk7XG4gICAgICAgICAgaWYgKGNoYXJzLmVuZHNXaXRoKG92ZXJsYXApIHx8IGNoYXJzLnN0YXJ0c1dpdGgob3ZlcmxhcCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0U3RyaW5nID0gcmlnaHRQYXJ0LnJlcGxhY2Uob3ZlcmxhcCwgXCJcIik7XG4gICAgICAgICAgICBjb25zdCBpbm5lclN0cmluZyA9IG92ZXJsYXA7XG4gICAgICAgICAgICBjb25zdCBsZWZ0U3RyaW5nID0gY29udGVudC5zdWJzdHJpbmcoMCwgc3BsaXRJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0RWxlbWVudENvbnRpbnVlcyA9IG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICByZW1haW5pbmdQYXJ0OiBuZXh0UGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBbbmV3RWxlbWVudCwgdXBkYXRlZEluZGV4XSA9IHNwbGl0RWxlbWVudCh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBlbGVtZW50VG9XcmFwOiBlbGVtZW50c1tpXSxcbiAgICAgICAgICAgICAgaW5uZXJTdHJpbmcsXG4gICAgICAgICAgICAgIHJpZ2h0U3RyaW5nLFxuICAgICAgICAgICAgICBsZWZ0U3RyaW5nLFxuICAgICAgICAgICAgICByZXN0LFxuICAgICAgICAgICAgICBuZXh0RWxlbWVudENvbnRpbnVlcyxcbiAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgIGlnbm9yZUNoYXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoYXJzU29GYXIgKz0gb3ZlcmxhcDtcbiAgICAgICAgICAgIHRvV3JhcC5wdXNoKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogbmV3RWxlbWVudCxcbiAgICAgICAgICAgICAgaW5kZXg6IHVwZGF0ZWRJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1dyYXA7XG59XG5cbi8vIHNyYy9jaGFycy93cmFwSGlnaGxpZ2h0ZWRDaGFycy50c1xuZnVuY3Rpb24gd3JhcEhpZ2hsaWdodGVkQ2hhcnMocGFyZW50RWxlbWVudCwgZWxlbWVudHNUb1dyYXAsIG9wdGlvbnMsIGlnbm9yZVdvcmQsIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzKSB7XG4gIGlmICghZWxlbWVudHNUb1dyYXAgfHwgZWxlbWVudHNUb1dyYXAubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt7IGVsZW1lbnQgfV0gPSBlbGVtZW50c1RvV3JhcDtcbiAgaWYgKGlnbm9yZVdvcmQpIHtcbiAgICBpZiAoZWxlbWVudC5wcm9wZXJ0aWVzKSB7XG4gICAgICBlbGVtZW50LnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudHNUb1dyYXAubGVuZ3RoID4gMSkge1xuICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4uc3BsaWNlKFxuICAgICAgZWxlbWVudHNUb1dyYXBbMF0uaW5kZXgsXG4gICAgICBlbGVtZW50c1RvV3JhcC5sZW5ndGgsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcIm1hcmtcIixcbiAgICAgICAgcHJvcGVydGllczogeyBcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnMtbWFya1wiOiBcIlwiIH0sXG4gICAgICAgIGNoaWxkcmVuOiBlbGVtZW50c1RvV3JhcC5tYXAoKHsgZWxlbWVudDogZWxlbWVudDMgfSkgPT4gZWxlbWVudDMpXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBlbGVtZW50MiA9IHBhcmVudEVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudHNUb1dyYXBbMF0uaW5kZXhdO1xuICAgIGlmICghaXNFbGVtZW50KGVsZW1lbnQyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3b3JkU3RyID0gZWxlbWVudDIuY2hpbGRyZW4ucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gaXNFbGVtZW50KG5vZGUpID8gbm9kZS5jaGlsZHJlblswXSA6IG51bGw7XG4gICAgICBpZiAoaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWNjICsgdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFwiXCIpO1xuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5pZHNNYXAuZ2V0KHdvcmRTdHIpO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXMgPSBlbGVtZW50Mi5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1jaGFycy1pZFwiXSA9IGlkO1xuICAgIGVsZW1lbnQyLnRhZ05hbWUgPSBcIm1hcmtcIjtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQyLCBpZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3sgZWxlbWVudDogZWxlbWVudDIgfV0gPSBlbGVtZW50c1RvV3JhcDtcbiAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQyLmNoaWxkcmVuWzBdO1xuICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRzTWFwLmdldCh0ZXh0RWxlbWVudC52YWx1ZSk7XG4gICAgZWxlbWVudDIucHJvcGVydGllcyA9IGVsZW1lbnQyLnByb3BlcnRpZXMgfHwge307XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1jaGFyc1wiXSA9IFwiXCI7XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtY2hhcnMtaWRcIl0gPSBpZDtcbiAgICBlbGVtZW50Mi50YWdOYW1lID0gXCJtYXJrXCI7XG4gICAgZWxlbWVudDIuY2hpbGRyZW4gPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHN0eWxlOiBlbGVtZW50Mi5wcm9wZXJ0aWVzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBlbGVtZW50Mi5jaGlsZHJlblxuICAgICAgfVxuICAgIF07XG4gICAgZWxlbWVudDIucHJvcGVydGllcy5zdHlsZSA9IHZvaWQgMDtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQyLCBpZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoYXJzSGlnaGxpZ2h0ZXIoZWxlbWVudCwgY2hhcnNMaXN0LCBvcHRpb25zLCBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycykge1xuICBjb25zdCB7IHJhbmdlcyA9IFtdIH0gPSBvcHRpb25zO1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRvU3RyaW5nKGVsZW1lbnQpO1xuICBjaGFyc0xpc3QuZm9yRWFjaCgoY2hhcnMsIGluZGV4KSA9PiB7XG4gICAgaWYgKGNoYXJzICYmIHRleHRDb250ZW50Py5pbmNsdWRlcyhjaGFycykpIHtcbiAgICAgIGxldCB0ZXh0Q29udGVudDIgPSB0b1N0cmluZyhlbGVtZW50KTtcbiAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0ZXh0Q29udGVudDIuaW5jbHVkZXMoY2hhcnMpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFyc1JhbmdlID0gcmFuZ2VzW2luZGV4XSB8fCBbXTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHtjaGFyc30tJHtpbmRleH1gO1xuICAgICAgICBvcHRpb25zLmNvdW50ZXJNYXAuc2V0KGlkLCAob3B0aW9ucy5jb3VudGVyTWFwLmdldChpZCkgfHwgMCkgKyAxKTtcbiAgICAgICAgY29uc3QgaWdub3JlQ2hhcnMgPSBjdXJyZW50Q2hhcnNSYW5nZS5sZW5ndGggPiAwICYmICFjdXJyZW50Q2hhcnNSYW5nZS5pbmNsdWRlcyhvcHRpb25zLmNvdW50ZXJNYXAuZ2V0KGlkKSA/PyAtMSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzVG9XcmFwID0gZ2V0RWxlbWVudHNUb0hpZ2hsaWdodChcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIGNoYXJzLFxuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgaWdub3JlQ2hhcnNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgd3JhcEhpZ2hsaWdodGVkQ2hhcnMoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBlbGVtZW50c1RvV3JhcCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGlnbm9yZUNoYXJzLFxuICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzXG4gICAgICAgICk7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heChcbiAgICAgICAgICBlbGVtZW50c1RvV3JhcFtlbGVtZW50c1RvV3JhcC5sZW5ndGggLSAxXS5pbmRleCAtIDIsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICB0ZXh0Q29udGVudDIgPSBlbGVtZW50LmNoaWxkcmVuLm1hcCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvcHMgPSBpc0VsZW1lbnQoY2hpbGROb2RlKSA/IGNoaWxkTm9kZS5wcm9wZXJ0aWVzIDoge307XG4gICAgICAgICAgaWYgKHByb3BzICYmICFPYmplY3QuaGFzT3duKHByb3BzLCBcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCIpICYmICFPYmplY3QuaGFzT3duKHByb3BzLCBcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnMtbWFya1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKGNoaWxkTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgaWYgKCFpc0VsZW1lbnQoY2hpbGROb2RlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihjaGlsZE5vZGUucHJvcGVydGllcywgXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiKSkge1xuICAgICAgY2hpbGROb2RlLnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGFwcGx5KGVsZW1lbnQsIHtcbiAgdHJlZSxcbiAgbGFuZyxcbiAgdGl0bGUsXG4gIGNhcHRpb24sXG4gIGlubGluZSA9IGZhbHNlLFxuICBrZWVwQmFja2dyb3VuZCA9IHRydWUsXG4gIGdyaWQgPSB0cnVlLFxuICBsaW5lTnVtYmVyc01heERpZ2l0cyA9IDEsXG4gIHRoZW1lLFxuICBvblZpc2l0VGl0bGUsXG4gIG9uVmlzaXRDYXB0aW9uXG59KSB7XG4gIGVsZW1lbnQudGFnTmFtZSA9IGlubGluZSA/IFwic3BhblwiIDogXCJmaWd1cmVcIjtcbiAgZWxlbWVudC5wcm9wZXJ0aWVzW1wiZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtZmlndXJlXCJdID0gXCJcIjtcbiAgY29uc3QgY29kZURhdGEgPSBlbGVtZW50LmNoaWxkcmVuWzBdPy5kYXRhO1xuICBlbGVtZW50LmNoaWxkcmVuID0gW3RyZWVdLm1hcCgodHJlZTIpID0+IHtcbiAgICBjb25zdCBwcmUgPSB0cmVlMi5jaGlsZHJlblswXTtcbiAgICBjb25zdCB0aGVtZU5hbWVzID0gZ2V0VGhlbWVOYW1lcyh0aGVtZSk7XG4gICAgY29uc3QgdGhlbWVOYW1lc1N0cmluZyA9IHRoZW1lTmFtZXMuam9pbihcIiBcIik7XG4gICAgaWYgKCEoaXNFbGVtZW50KHByZSkgJiYgcHJlLnByb3BlcnRpZXMpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBwcmUuY2hpbGRyZW5bMF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lKSAmJiBwcmUucHJvcGVydGllcy5jbGFzc05hbWUuaW5jbHVkZXMoXCJzaGlraVwiKSkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gcHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lLmZpbHRlcihcbiAgICAgICAgKGMpID0+IGMgIT09IFwic2hpa2lcIiAmJiBjICE9PSBcInNoaWtpLXRoZW1lc1wiICYmICh0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIiA/ICF0aGVtZU5hbWVzLmluY2x1ZGVzKGMpIDogdHJ1ZSlcbiAgICAgICk7XG4gICAgICBwcmUucHJvcGVydGllcy5jbGFzc05hbWUgPSBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKCFrZWVwQmFja2dyb3VuZCkge1xuICAgICAgcHJlLnByb3BlcnRpZXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIHByZS5wcm9wZXJ0aWVzW1wiZGF0YS1sYW5ndWFnZVwiXSA9IGxhbmc7XG4gICAgcHJlLnByb3BlcnRpZXNbXCJkYXRhLXRoZW1lXCJdID0gdGhlbWVOYW1lc1N0cmluZztcbiAgICBpZiAoIShpc0VsZW1lbnQoY29kZSkgJiYgY29kZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLWxhbmd1YWdlXCJdID0gbGFuZztcbiAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLXRoZW1lXCJdID0gdGhlbWVOYW1lc1N0cmluZztcbiAgICBjb2RlLmRhdGEgPSBjb2RlRGF0YTtcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBpZiAoa2VlcEJhY2tncm91bmQpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlID0gcHJlLnByb3BlcnRpZXMuc3R5bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgaWYgKGdyaWQpIHtcbiAgICAgIGlmIChjb2RlLnByb3BlcnRpZXMuc3R5bGUpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlICs9IFwiZGlzcGxheTogZ3JpZDtcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUucHJvcGVydGllcy5zdHlsZSA9IFwiZGlzcGxheTogZ3JpZDtcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5oYXNPd24oY29kZS5wcm9wZXJ0aWVzLCBcImRhdGEtbGluZS1udW1iZXJzXCIpKSB7XG4gICAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLWxpbmUtbnVtYmVycy1tYXgtZGlnaXRzXCJdID0gbGluZU51bWJlcnNNYXhEaWdpdHMudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IFtdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc3QgZWxlbWVudENvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBjYXB0aW9uID8gXCJkaXZcIiA6IFwiZmlnY2FwdGlvblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS10aXRsZVwiOiBcIlwiLFxuICAgICAgICAgIFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLFxuICAgICAgICAgIFwiZGF0YS10aGVtZVwiOiB0aGVtZU5hbWVzU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHRpdGxlIH1dXG4gICAgICB9O1xuICAgICAgb25WaXNpdFRpdGxlPy4oZWxlbWVudENvbnRlbnQpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZWxlbWVudENvbnRlbnQpO1xuICAgIH1cbiAgICBmcmFnbWVudHMucHVzaChwcmUpO1xuICAgIGlmIChjYXB0aW9uKSB7XG4gICAgICBjb25zdCBlbGVtZW50Q29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwiZmlnY2FwdGlvblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS1jYXB0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcsXG4gICAgICAgICAgXCJkYXRhLXRoZW1lXCI6IHRoZW1lTmFtZXNTdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogY2FwdGlvbiB9XVxuICAgICAgfTtcbiAgICAgIG9uVmlzaXRDYXB0aW9uPy4oZWxlbWVudENvbnRlbnQpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZWxlbWVudENvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRzO1xuICB9KS5mbGF0TWFwKChjKSA9PiBjKTtcbn1cbnZhciBnbG9iYWxIaWdobGlnaHRlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBoYXN0UGFyc2VyID0gdW5pZmllZCgpLnVzZShyZWh5cGVQYXJzZSwgeyBmcmFnbWVudDogdHJ1ZSB9KTtcbnZhciBzcmNfZGVmYXVsdCA9IHJlaHlwZVByZXR0eUNvZGU7XG5mdW5jdGlvbiByZWh5cGVQcmV0dHlDb2RlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZ3JpZCA9IHRydWUsXG4gICAgdGhlbWUgPSBcImdpdGh1Yi1kYXJrLWRpbW1lZFwiLFxuICAgIGtlZXBCYWNrZ3JvdW5kID0gdHJ1ZSxcbiAgICBkZWZhdWx0TGFuZyA9IFwiXCIsXG4gICAgdG9rZW5zTWFwID0ge30sXG4gICAgZmlsdGVyTWV0YVN0cmluZyA9ICh2KSA9PiB2LFxuICAgIGdldEhpZ2hsaWdodGVyOiBnZXRIaWdobGlnaHRlciQxID0gZ2V0SGlnaGxpZ2h0ZXIsXG4gICAgdHJhbnNmb3JtZXJzLFxuICAgIG9uVmlzaXRMaW5lLFxuICAgIG9uVmlzaXRIaWdobGlnaHRlZExpbmUsXG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMsXG4gICAgb25WaXNpdFRpdGxlLFxuICAgIG9uVmlzaXRDYXB0aW9uXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeSh0aGVtZSk7XG4gIGxldCBjYWNoZWRIaWdobGlnaHRlciA9IGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUuZ2V0KGtleSk7XG4gIGlmICghY2FjaGVkSGlnaGxpZ2h0ZXIpIHtcbiAgICBjYWNoZWRIaWdobGlnaHRlciA9IGdldEhpZ2hsaWdodGVyJDEoe1xuICAgICAgdGhlbWVzOiBpc0pTT05UaGVtZSh0aGVtZSkgfHwgdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gW3RoZW1lXSA6IE9iamVjdC52YWx1ZXModGhlbWUpLFxuICAgICAgbGFuZ3M6IFtcInBsYWludGV4dFwiXVxuICAgIH0pO1xuICAgIGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUuc2V0KGtleSwgY2FjaGVkSGlnaGxpZ2h0ZXIpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRDb2RlQmxvY2tMYW5nID0gdHlwZW9mIGRlZmF1bHRMYW5nID09PSBcInN0cmluZ1wiID8gZGVmYXVsdExhbmcgOiBkZWZhdWx0TGFuZy5ibG9jayB8fCBcIlwiO1xuICBjb25zdCBkZWZhdWx0SW5saW5lQ29kZUxhbmcgPSB0eXBlb2YgZGVmYXVsdExhbmcgPT09IFwic3RyaW5nXCIgPyBkZWZhdWx0TGFuZyA6IGRlZmF1bHRMYW5nLmlubGluZSB8fCBcIlwiO1xuICBmdW5jdGlvbiBnZXRPcHRpb25zKGxhbmcsIG1ldGEpIHtcbiAgICBjb25zdCBtdWx0aXBsZVRoZW1lcyA9ICFpc0pTT05UaGVtZSh0aGVtZSkgJiYgdHlwZW9mIHRoZW1lID09PSBcIm9iamVjdFwiID8gdGhlbWUgOiBudWxsO1xuICAgIGNvbnN0IHNpbmdsZVRoZW1lID0gaXNKU09OVGhlbWUodGhlbWUpIHx8IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZyxcbiAgICAgIG1ldGE6IHsgX19yYXc6IG1ldGEgfSxcbiAgICAgIHRyYW5zZm9ybWVycyxcbiAgICAgIGRlZmF1bHRDb2xvcjogdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiBmYWxzZSxcbiAgICAgIC4uLm11bHRpcGxlVGhlbWVzID8geyB0aGVtZXM6IG11bHRpcGxlVGhlbWVzIH0gOiB7IHRoZW1lOiBzaW5nbGVUaGVtZSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXN5bmMgKHRyZWUpID0+IHtcbiAgICBjb25zdCBsYW5nc1RvTG9hZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZXIgPSBhd2FpdCBjYWNoZWRIaWdobGlnaHRlcjtcbiAgICBpZiAoIWhpZ2hsaWdodGVyKVxuICAgICAgcmV0dXJuO1xuICAgIHZpc2l0KHRyZWUsIFwiZWxlbWVudFwiLCAoZWxlbWVudCwgXywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoaXNJbmxpbmVDb2RlKGVsZW1lbnQsIHBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGFuZyA9IGdldElubGluZUNvZGVMYW5nKHZhbHVlLCBkZWZhdWx0SW5saW5lQ29kZUxhbmcpO1xuICAgICAgICBpZiAobGFuZyAmJiBsYW5nWzBdICE9PSBcIi5cIikge1xuICAgICAgICAgIGxhbmdzVG9Mb2FkLmFkZChsYW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tDb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoY29kZUVsZW1lbnQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBsYW5nIH0gPSBwYXJzZUJsb2NrTWV0YVN0cmluZyhcbiAgICAgICAgICBjb2RlRWxlbWVudCxcbiAgICAgICAgICBmaWx0ZXJNZXRhU3RyaW5nLFxuICAgICAgICAgIGRlZmF1bHRDb2RlQmxvY2tMYW5nXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgbGFuZ3NUb0xvYWQuYWRkKGxhbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICAgICAgQXJyYXkuZnJvbShsYW5nc1RvTG9hZCkubWFwKChsYW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRlci5sb2FkTGFuZ3VhZ2UoXG4gICAgICAgICAgICAgIGxhbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdmlzaXQodHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50LCBfLCBwYXJlbnQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUNvZGUoZWxlbWVudCwgcGFyZW50KSkge1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBrZWVwTGFuZ1BhcnQgPSAvXFxcXHs6W2EtekEtWi4tXSt9JC8udGVzdCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSBrZWVwTGFuZ1BhcnQgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcKHs6W2EtekEtWi4tXSt9KSQvLCBcIiQxXCIpIDogdmFsdWUucmVwbGFjZSgvezpbYS16QS1aLi1dK30kLywgXCJcIik7XG4gICAgICAgIHRleHRFbGVtZW50LnZhbHVlID0gc3RyaXBwZWRWYWx1ZTtcbiAgICAgICAgY29uc3QgbGFuZyA9IGtlZXBMYW5nUGFydCA/IFwiXCIgOiBnZXRJbmxpbmVDb2RlTGFuZyh2YWx1ZSwgZGVmYXVsdElubGluZUNvZGVMYW5nKTtcbiAgICAgICAgY29uc3QgaXNMYW5nID0gbGFuZ1swXSAhPT0gXCIuXCI7XG4gICAgICAgIGlmICghbGFuZylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2RlVHJlZTtcbiAgICAgICAgaWYgKGlzTGFuZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhsYW5nKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhcInBsYWludGV4dFwiKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRoZW1lTmFtZXMgPSBnZXRUaGVtZU5hbWVzKHRoZW1lKTtcbiAgICAgICAgICBjb25zdCBpc011bHRpVGhlbWUgPSB0eXBlb2YgdGhlbWUgPT09IFwib2JqZWN0XCIgJiYgIWlzSlNPTlRoZW1lKHRoZW1lKTtcbiAgICAgICAgICBjb25zdCB0aGVtZUtleXMgPSBpc011bHRpVGhlbWUgPyBPYmplY3Qua2V5cyh0aGVtZSkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGNvbG9yc0J5VGhlbWUgPSB0aGVtZU5hbWVzLm1hcChcbiAgICAgICAgICAgIChuYW1lKSA9PiBuYW1lID8gaGlnaGxpZ2h0ZXIuZ2V0VGhlbWUobmFtZSkuc2V0dGluZ3MuZmluZChcbiAgICAgICAgICAgICAgKHsgc2NvcGUgfSkgPT4gc2NvcGU/LmluY2x1ZGVzKHRva2Vuc01hcFtsYW5nLnNsaWNlKDEpXSA/PyBsYW5nLnNsaWNlKDEpKVxuICAgICAgICAgICAgKT8uc2V0dGluZ3MuZm9yZWdyb3VuZCA/PyBcImluaGVyaXRcIiA6IFwiaW5oZXJpdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNNdWx0aVRoZW1lICYmIHRoZW1lS2V5cykge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBgPHByZT48Y29kZT48c3BhbiBzdHlsZT1cIiR7dGhlbWVLZXlzLm1hcCgoa2V5MiwgaSkgPT4gYC0tc2hpa2ktJHtrZXkyfToke2NvbG9yc0J5VGhlbWVbaV19YCkuam9pbihcIjtcIil9XCI+JHtzdHJpcHBlZFZhbHVlfTwvc3Bhbj48L2NvZGU+PC9wcmU+YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBgPHByZT48Y29kZT48c3BhbiBzdHlsZT1cImNvbG9yOiR7Y29sb3JzQnlUaGVtZVswXX1cIj4ke3N0cmlwcGVkVmFsdWV9PC9zcGFuPjwvY29kZT48L3ByZT5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdChjb2RlVHJlZSwgXCJlbGVtZW50XCIsIHJlcGxhY2VMaW5lQ2xhc3MpO1xuICAgICAgICBhcHBseShlbGVtZW50LCB7XG4gICAgICAgICAgdHJlZTogY29kZVRyZWUsXG4gICAgICAgICAgbGFuZzogaXNMYW5nID8gbGFuZyA6IFwiLnRva2VuXCIsXG4gICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgIGtlZXBCYWNrZ3JvdW5kLFxuICAgICAgICAgIHRoZW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tDb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoY29kZUVsZW1lbnQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBjb2RlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgY29uc3QgeyB0aXRsZSwgY2FwdGlvbiwgbWV0YSwgbGFuZyB9ID0gcGFyc2VCbG9ja01ldGFTdHJpbmcoXG4gICAgICAgICAgY29kZUVsZW1lbnQsXG4gICAgICAgICAgZmlsdGVyTWV0YVN0cmluZyxcbiAgICAgICAgICBkZWZhdWx0Q29kZUJsb2NrTGFuZ1xuICAgICAgICApO1xuICAgICAgICBpZiAoIWxhbmcgfHwgbGFuZyA9PT0gXCJtYXRoXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaW5lTnVtYmVycyA9IFtdO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBtZXRhLm1hdGNoQWxsKC9cXEJcXHsoLio/KVxcfVxcQi9nKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICBsaW5lTnVtYmVycy5wdXNoKC4uLnJhbmdlUGFyc2VyMihtYXRjaFsxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZU51bWJlcnNNYXhEaWdpdHMgPSAwO1xuICAgICAgICBjb25zdCBsaW5lSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgY2hhcnNMaXN0TnVtYmVycyA9IFtdO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3RJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNoYXJzTWF0Y2hlcyA9IG1ldGEgPyBbXG4gICAgICAgICAgLi4ubWV0YS5tYXRjaEFsbChcbiAgICAgICAgICAgIC8oPzxkZWxpbWl0ZXI+W1wiL10pKD88Y2hhcnM+Lio/KVxcazxkZWxpbWl0ZXI+KD88Y2hhcnNJZEFuZE9yUmFuZ2U+XFxTKikvZ1xuICAgICAgICAgIClcbiAgICAgICAgXSA6IHZvaWQgMDtcbiAgICAgICAgbGluZU51bWJlcnMuZm9yRWFjaCgobGluZU51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gZ2V0TGluZUlkKGxpbmVOdW1iZXIsIG1ldGEpO1xuICAgICAgICAgIGlkICYmIGxpbmVJZE1hcC5zZXQobGluZU51bWJlciwgaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhcnNNYXRjaGVzKSkge1xuICAgICAgICAgIGNoYXJzTWF0Y2hlcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYXJzLCBjaGFyc0lkQW5kT3JSYW5nZSB9ID0gbmFtZS5ncm91cHM7XG4gICAgICAgICAgICBjaGFyc0xpc3QucHVzaChjaGFycyk7XG4gICAgICAgICAgICBpZiAoY2hhcnNJZEFuZE9yUmFuZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgY2hhcnNMaXN0TnVtYmVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtyYW5nZSwgaWRdID0gY2hhcnNJZEFuZE9yUmFuZ2Uuc3BsaXQoXCIjXCIpO1xuICAgICAgICAgICAgICByYW5nZSAmJiBjaGFyc0xpc3ROdW1iZXJzLnB1c2gocmFuZ2VQYXJzZXIyKHJhbmdlKSk7XG4gICAgICAgICAgICAgIGlkICYmIGNoYXJzTGlzdElkTWFwLnNldChjaGFycywgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSB0ZXh0RWxlbWVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgXCJcIik7XG4gICAgICAgIGxldCBjb2RlVHJlZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIGdldE9wdGlvbnMobGFuZywgbWV0YSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChcbiAgICAgICAgICAgICAgc3RyaXBwZWRWYWx1ZSxcbiAgICAgICAgICAgICAgZ2V0T3B0aW9ucyhcInBsYWludGV4dFwiLCBtZXRhKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVDb3VudGVyID0gMDtcbiAgICAgICAgY29uc3QgY2hhcnNIaWdobGlnaHRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgcmFuZ2VzOiBjaGFyc0xpc3ROdW1iZXJzLFxuICAgICAgICAgIGlkc01hcDogY2hhcnNMaXN0SWRNYXAsXG4gICAgICAgICAgY291bnRlck1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICB2aXNpdChjb2RlVHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50MikgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50Mi50YWdOYW1lID09PSBcImNvZGVcIiAmJiAvc3JlYm11TmVuaUx3b2hzKD8hKC4qKShcXC8pKS8udGVzdChyZXZlcnNlU3RyaW5nKG1ldGEpKSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtbGluZS1udW1iZXJzXCJdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXJzU3RhcnRBdE1hdGNoID0gcmV2ZXJzZVN0cmluZyhtZXRhKS5tYXRjaChcbiAgICAgICAgICAgICAgLyg/OlxcfShcXGQrKXspP3NyZWJtdU5lbmlMd29ocyg/ISguKikoXFwvKSkvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnROdW1iZXJTdHJpbmcgPSBsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaD8uWzFdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0TnVtYmVyU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0QXQgPSBzdGFydE51bWJlclN0cmluZyA/IE51bWJlcihyZXZlcnNlU3RyaW5nKHN0YXJ0TnVtYmVyU3RyaW5nKSkgLSAxIDogMDtcbiAgICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMgPSBzdGFydEF0O1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudDIucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXMuc3R5bGUgPSBgY291bnRlci1zZXQ6IGxpbmUgJHtzdGFydEF0fTtgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQyLnByb3BlcnRpZXM/LmNsYXNzTmFtZSkgJiYgZWxlbWVudDIucHJvcGVydGllcz8uY2xhc3NOYW1lPy5bMF0gPT09IFwibGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZCAmJiB0b1N0cmluZyhlbGVtZW50MikgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIuY2hpbGRyZW4gPSBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFwiIFwiIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZUxpbmVDbGFzcyhlbGVtZW50Mik7XG4gICAgICAgICAgICBvblZpc2l0TGluZT8uKGVsZW1lbnQyKTtcbiAgICAgICAgICAgIGxpbmVDb3VudGVyKys7XG4gICAgICAgICAgICBpZiAobGluZU51bWJlcnMuaW5jbHVkZXMobGluZUNvdW50ZXIpKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWxpbmVcIl0gPSBcIlwiO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lSWQgPSBsaW5lSWRNYXAuZ2V0KGxpbmVDb3VudGVyKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVJZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWxpbmUtaWRcIl0gPSBsaW5lSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb25WaXNpdEhpZ2hsaWdodGVkTGluZT8uKGVsZW1lbnQyLCBsaW5lSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnNIaWdobGlnaHRlcihcbiAgICAgICAgICAgICAgZWxlbWVudDIsXG4gICAgICAgICAgICAgIGNoYXJzTGlzdCxcbiAgICAgICAgICAgICAgY2hhcnNIaWdobGlnaHRlck9wdGlvbnMsXG4gICAgICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcHBseShlbGVtZW50LCB7XG4gICAgICAgICAgdHJlZTogY29kZVRyZWUsXG4gICAgICAgICAgbGFuZyxcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICBjYXB0aW9uLFxuICAgICAgICAgIGtlZXBCYWNrZ3JvdW5kLFxuICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMsXG4gICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgb25WaXNpdFRpdGxlLFxuICAgICAgICAgIG9uVmlzaXRDYXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgeyBzcmNfZGVmYXVsdCBhcyBkZWZhdWx0LCByZWh5cGVQcmV0dHlDb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/dist/index.js\n");

/***/ })

};
;